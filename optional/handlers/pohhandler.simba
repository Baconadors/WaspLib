(*
POHHandler
==========
*)

{$DEFINE WL_POH_HANDLER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/optional.simba}
{$ENDIF}

type
  ERSHouseRoom = (
    UNKNOWN, GARDEN, SUPERIOR_GARDEN, MENAGERIE_OPEN, MENAGERIE_CLOSED,
    STUDY_PARLOUR, KITCHEN_BEDROOM, ACHIEVEMENT_GALLERY, QUEST_NEXUS, COMBAT,
    COSTUME, ALTAR, PORTAL, WORKSHOP
  );

  ERSHouseRoomArray = array of ERSHouseRoom;
  E2DRSHouseRoomArray = array of ERSHouseRoomArray;

  TRSPOHHandler = record
    Size: Int32;
    RoomsMap, Map: TMufasaBitmap;
    RoomsBitmaps: array [ERSHouseRoom] of TMufasaBitmap;
    Rooms: E2DRSHouseRoomArray;
    GrassColor: Int32;
    Similarity: Double;
  end;

procedure TRSPOHHandler.Free();
var
  room: ERSHouseRoom;
begin
  Self.Map.Free();
  Self.RoomsMap.Free();
  for room := ERSHouseRoom(0) to ERSHouseRoom(High(ERSHouseRoom)) do
    if Self.RoomsBitmaps[room] <> nil then
      Self.RoomsBitmaps[room].Free();
end;

procedure TRSPOHHandler.Init();
const
  ROOM_NUMBER: Int32 = 10;
var
  i: Int32;
begin
  Self.Size := 32;
  Self.Similarity := 0.9999;

  Self.Map.Init();
  Self.Map.SetSize(Self.Size * ROOM_NUMBER, Self.Size * ROOM_NUMBER);

  Self.RoomsMap.Init();
  Self.RoomsMap.LoadFromFile(WALKER_DIR + 'poh.png');
  SetLength(Self.Rooms, ROOM_NUMBER);
  for i := 0 to High(Self.Rooms) do
    SetLength(Self.Rooms[i], ROOM_NUMBER);

  AddOnTerminate(@Self.Free);
end;

function TRSPOHHandler.GetRoom(i: Int32): ERSHouseRoom;
begin
  Result := ERSHouseRoom((i div Self.Size) + 1);
end;

function TRSPOHHandler.GetRoomBox(room: ERSHouseRoom): TBox;
var
  i: Int32;
begin
  i := Ord(room)-1;
  Result := [i * Self.Size, 0, i * Self.Size + Self.Size - 1, Self.Size-1];
end;

function TRSPOHHandler.GetRoomBitmap(room: ERSHouseRoom; color: Int32 = -1): TMufasaBitmap;
var
  b: TBox;
begin
  if Self.RoomsBitmaps[room] = nil then
  begin
    b := Self.GetRoomBox(room);
    Result := Self.RoomsMap.Copy(b.X1, b.Y1, b.X2, b.Y2);
    Self.RoomsBitmaps[room] := Result.Copy();
  end
  else
    Result := Self.RoomsBitmaps[room].Copy();

  if color <> -1 then
    Result.ReplaceColor($FFFFFF, color);
end;



procedure TRSPOHHandler.WriteRoom(room: ERSHouseRoom; x, y: Int32);
begin
  if not InRange(x, 0, High(Self.Rooms)) then
    TerminateScript('x has to be between 0 and ' + ToStr(High(Self.Rooms)) + ', got: ' + ToStr(x));
  if not InRange(y, 0, High(Self.Rooms[0])) then
    TerminateScript('y has to be between 0 and ' + ToStr(High(Self.Rooms[0])) + ', got: ' + ToStr(y));

  Self.Rooms[y,x] := room;
end;

procedure TRSPOHHandler.WriteRoom(room: ERSHouseRoom; p: TPoint); overload;
begin
  Self.WriteRoom(room, p.X, p.Y);
end;

function TRSPOHHandler.ReadRoom(x, y: Int32): ERSHouseRoom;
begin
  if not InRange(x, 0, High(Self.Rooms)) then
    TerminateScript('x has to be between 0 and ' + ToStr(High(Self.Rooms)) + ', got: ' + ToStr(x));
  if not InRange(y, 0, High(Self.Rooms[0])) then
    TerminateScript('y has to be between 0 and ' + ToStr(High(Self.Rooms[0])) + ', got: ' + ToStr(y));

  Result := Self.Rooms[y,x];
end;

function TRSPOHHandler.ReadRoom(p: TPoint): ERSHouseRoom; overload;
begin
  Result := Self.ReadRoom(p.X, p.Y);
end;


procedure TRSPOHHandler.DrawMap(bmp: TMufasaBitmap; room: ERSHouseRoom; x, y: Int32);
begin
  Self.WriteRoom(room, x, y);
  Self.Map.DrawBitmap(bmp, [Self.Size * x, Self.Size * y]);
end;

procedure TRSPOHHandler.DrawMap(bmp: TMufasaBitmap; room: ERSHouseRoom; p: TPoint); overload;
begin
  Self.DrawMap(bmp, room, p.X, p.Y);
end;

procedure TRSPOHHandler.DrawMap(room: ERSHouseRoom; color: Int32; x, y: Int32); overload;
var
  bmp: TMufasaBitmap;
begin
  bmp := Self.GetRoomBitmap(room, color);
  Self.DrawMap(bmp, room, x, y);
  bmp.Free();
end;

procedure TRSPOHHandler.DrawMap(room: ERSHouseRoom; color: Int32; p: TPoint); overload;
begin
  Self.DrawMap(room, color, p.X, p.Y);
end;



function TRSPOHHandler.GetMappedRoom(p: TPoint): ERSHouseRoom;
begin
  Result := Self.ReadRoom(p.Y div Self.Size, p.X div Self.Size);
end;

function TRSPOHHandler.GetMappedRoomIndices(p: TPoint): TPoint;
begin
  Result := [p.Y div Self.Size, p.X div Self.Size];
end;

function TRSPOHHandler.GetMappedRoomTopLeft(p: TPoint): TPoint;
begin
  Result := [p.X div Self.Size * Self.Size, p.Y div Self.Size * Self.Size];
end;


function TRSPOHHandler.GetAdjacentRoomsMinimap(p: TPoint): TPointArray;
begin
  Result := [p.Offset(-32,0), p.Offset(32, 0), p.Offset(0, -32), p.Offset(0, 32)];
end;

function TRSPOHHandler.GetAdjacentRoomsIndices(p: TPoint): TPointArray;
begin
  Result := [p.Offset(-1,0), p.Offset(1, 0), p.Offset(0, -1), p.Offset(0, 1)];
end;


function TRSPOHHandler.RotateRoom(bitmap: TMufasaBitmap; rotation: Int32): TMufasaBitmap;
var
  p: TPoint;
begin
  if rotation = 0 then
    Exit(bitmap.Copy());

  Result.Init();
  bitmap.RotateBitmap(PI/2*rotation, Result);
  for p.X := 0 to 3 do
    for p.Y := 0 to 3 do
      if Result.GetPixel(p.X, p.Y) <> 0 then
        Break(2);

  Result.Crop(p.X, p.Y, p.X + 31, p.Y + 31);
end;

procedure TRSPOHHandler.MapAdjacentRooms(minimapBMP: TMufasaBitmap; topLeft, currentRoom: TPoint);
const
  COLOR_OFFSETS: TPointArray = [[5,5], [26,5], [26,26], [5, 26]];
var
  minimapTPA, localTPA: TPointArray;
  p: TPoint;
  crop, sample, rotated, bestBMP: TMufasaBitmap;
  i, j, floor, r: Int32;
  colors: TIntegerArray;
  bestRoom: ERSHouseRoom;
  matrix: TSingleMatrix;
  bestMatch: Single;
begin
  localTPA := Self.GetAdjacentRoomsIndices(currentRoom);

  minimapTPA := Self.GetAdjacentRoomsMinimap(topLeft);

  for i := 0 to High(minimapTPA) do
  begin
    p := minimapTPA[i];

    if Self.GetMappedRoom(p) <> ERSHouseRoom.UNKNOWN then
      Continue;

    crop := minimapBMP.Copy(p.X, p.Y, p.X + Self.Size-1, p.Y + Self.Size-1);

    colors := crop.GetPixels(COLOR_OFFSETS);
    floor := colors.GetMostCommon();

    for j := 1 to Ord(High(ERSHouseRoom)) do
    begin
      case j of
        0..3: if floor <> Self.GrassColor then Continue; //Gardens or OpenMenagerie
        else  if floor = Self.GrassColor then Continue;
      end;

      sample := Self.GetRoomBitmap(ERSHouseRoom(j), floor);
      sample.Pad(1);
      for r := 0 to 3 do
      begin
        rotated := Self.RotateRoom(sample, j);
        matrix := crop.MatchTemplate(rotated, TM_CCOEFF_NORMED);

        if matrix.Max() > bestMatch then
        begin
          if bestBMP <> nil then
            bestBMP.Free();

          bestBMP := rotated;
          bestMatch := matrix.Max();
          bestRoom := ERSHouseRoom(j);
          Continue;
        end;

        rotated.Free();

        if bestMatch >= Self.Similarity then
          Break(2);
      end;
    end;

    crop.Free();

    Self.DrawMap(bestBMP, bestRoom, localTPA[i].X, localTPA[i].Y);
    bestMatch := 0;
  end;
  bestBMP.Free();
end;


procedure TRSPOHHandler.PrintRooms();
var
  str: String;
  i, j: Int32;
begin
  str := '[' + LineEnding;
  for i := 0 to High(Self.Rooms) do
  begin
    for j := 0 to High(Self.Rooms[i]) do
    begin
      if j = 0 then
      begin
        str += '  [';
      end;
        str += ToStr(Self.Rooms[i][j]);
      if j < High(Self.Rooms[i]) then
        str += ', ';
    end;
      str += ', ' + LineEnding;
  end;
  str += ']';
  WriteLn str;
end;


function TRSPOHHandler.GetCleanMinimap(out angle: Double): TMufasaBitmap; static;
var
  bitmap: TMufasaBitmap;
begin
  bitmap := GetMufasaBitmap(BitmapFromClient(Minimap.Bounds()));
  bitmap.ReplaceColor(0, 1); // We need zero to be unique

  TRSWalker.CleanMinimap(Bitmap);

  Result.Init();
  angle := Minimap.GetCompassAngle(False);
  bitmap.RotateBitmapEx(angle, False, True, Result);
  bitmap.Free();
end;

function TRSPOHHandler.GetCleanMinimap(): TMufasaBitmap; static; overload;
var
  angle: Double;
begin
  Result := TRSPOHHandler.GetCleanMinimap(angle);
end;

procedure TRSPOHHandler.Setup();
var
  minimapBMP: TMufasaBitmap;
  center, topLeft: TPoint;
begin
  minimapBMP := TRSPOHHandler.GetCleanMinimap();
  center := minimapBMP.getCenter();
  Self.GrassColor := minimapBMP.GetPixel(center.X, center.Y);
  minimapBMP.ReplaceColor(1, Self.GrassColor);

  Self.Map.ReplaceColor(0, Self.GrassColor);

  Self.DrawMap(ERSHouseRoom.GARDEN, Self.GrassColor, 4, 4);
  topLeft := center.Offset(-14, -10);
  Self.MapAdjacentRooms(minimapBMP, topLeft, [4, 4]);

  minimapBMP.Free();
end;


function TRSPOHHandler.MapToMM(p, handlerPoint: TPoint; radians: Double): TPoint;
begin
  Result := handlerPoint - p + Minimap.Center();
  Result := Result.Rotate(radians, Minimap.Center());
end;

function TRSPOHHandler.GetPos(): TPoint;
var
  minimapBMP, sample: TMufasaBitmap;
  b: TBox;
  matrix: TSingleMatrix;
begin
  minimapBMP := TRSWalker.GetCleanMinimap();
  minimapBMP.ReplaceColor(1, Self.GrassColor);
  b := Box(sample.getCenter().Offset(2, 5), 20, 20);
  sample := minimapBMP.Copy(b.X1, b.Y1, b.X2, b.Y2);

  matrix := Self.Map.MatchTemplate(sample, TM_CCOEFF_NORMED);

  Result := matrix.ArgMax().Offset(17, 15);

  Self.MapAdjacentRooms(
    minimapBMP, Self.GetMappedRoomTopLeft(Result),
    Self.GetMappedRoomIndices(Result)
  );

  minimapBMP.Free();
  sample.Free();
end;

procedure TRSPOHHandler.DebugPos();
var
  minimapBMP, sample, display: TMufasaBitmap;
  b: TBox;
  matrix: TSingleMatrix;
  p, topLeft: TPoint;
  angle: Double;
begin
  minimapBMP := TRSPOHHandler.GetCleanMinimap(angle);
  minimapBMP.ReplaceColor(1, Self.GrassColor);
  b := Box(minimapBMP.getCenter().Offset(2, 5), 20, 20);
  sample := minimapBMP.Copy(b.X1, b.Y1, b.X2, b.Y2);

  matrix := Self.Map.MatchTemplate(sample, TM_CCOEFF_NORMED);

  p := matrix.ArgMax().Offset(17, 15);

  topLeft := p - Self.GetMappedRoomTopLeft(p);
  topLeft := minimapBMP.getCenter() - topLeft - [1,0];
  Self.MapAdjacentRooms(minimapBMP, topLeft, Self.GetMappedRoomIndices(p));

  display.Init();
  display.SetSize(Self.Map.getWidth() + sample.getWidth(), Self.Map.getHeight());

  display.DrawBitmap(Self.Map, [0,0]);
  display.DrawBitmap(sample, [Self.Map.getWidth()+1, 0]);

  display.DrawTPA([p, Self.GetMappedRoomTopLeft(p)], $FFFFFF);
  display.Debug();

  minimapBMP.Free();
  sample.Free();
  display.Free();
end;

function TRSPOHHandler.GetCurrentRoom(): ERSHouseRoom;
begin
  Result := Self.GetMappedRoom(Self.GetPos());
end;


var
  POHHandler: TRSPOHHandler;

procedure TSRL.Setup(); override;
begin
  inherited;

  POHHandler.Init();
end;


(*
begin
  ClearDebug();
  POHHandler.Setup();
  Wait(7000);
  while True do
    POHHandler.DebugPos();
end;
*)

