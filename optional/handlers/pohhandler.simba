(*
# POHHandler
The POH Handler is a handler responsible for making sense of a player's POH (Player Owned House) without
knowing any info about it's setup in advance.

```{note}
:class: dropdown
The POH Handler is optional and has to be explicitly included.
You can include it by either including all optional files which is not recommended:
  ```pascal
  {$I WaspLib/optional.simba}
  ```
Or include just the POHHandler file which is the recommended way to include it:
  ```pascal
  {$I WaspLib/optional/handlers/poh.simba}
  ```
```

Several rooms in a POH are unique on the minimap, with windows and/or doors of several sizes and different places.
By having this rooms saved in the following format:
```{figure} ../../../osr/walker/poh.png
Most relevant rooms for a POH stripped of their floor colors
```
We can attempt to match what we have on the minimap to those rooms and slowly build a map of the POH.

Some rooms share the same room layout or are very similar to others and for those we use some mainscreen information to make up what the room is,
e.g., Nexus room, Combat Hall and Quest Hall are all identical.
*)

{$DEFINE WL_POH_HANDLER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{$IFNDEF WL_HOUSEOBJECTS_INCLUDED}
  {$I WaspLib/optional/handlers/houseobjects.simba}
{$ENDIF}

{$SCOPEDENUMS ON}
type
  ERSHouseRoom = (
    UNKNOWN, GARDEN, SUPERIOR_GARDEN, MENAGERIE_OPEN, MENAGERIE_CLOSED,
    STUDY_PARLOUR, KITCHEN_BEDROOM, ACHIEVEMENT_GALLERY, QUEST_NEXUS, COMBAT,
    COSTUME, ALTAR, PORTAL, WORKSHOP
  );

  TRSPOHHandler = record
    AMOUNT, SIZE: Int32;
    RoomsMap, Map: TMufasaBitmap;
    RoomsBitmaps: array [ERSHouseRoom] of TMufasaBitmap;
    Rooms: array of array of ERSHouseRoom;
    RoomObjects: array [ERSRoomObject] of TRoomObject;
    GrassColor: Int32;
    Similarity: Double;
  end;
{$SCOPEDENUMS OFF}

(*
# POH.Free()
```pascal
procedure TRSPOHHandler.Free();
```
Internal method automatically called for your on script termination.
You do not have to call it yourself.
*)
procedure TRSPOHHandler.Free();
var
  room: ERSHouseRoom;
begin
  Self.Map.Free();
  Self.RoomsMap.Free();
  for room := Low(ERSHouseRoom) to High(ERSHouseRoom) do
    if Self.RoomsBitmaps[room] <> nil then
      Self.RoomsBitmaps[room].Free();
end;

(*
# POH.Init()
```pascal
procedure TRSPOHHandler.Init();
```
Internal method automatically called for your on script startup along with SRL.Setup().
You do not have to call it yourself.
*)
procedure TRSPOHHandler.Init();
var
  i: Int32;
  obj: ERSRoomObject;
begin
  Self.SIZE := 32;
  Self.AMOUNT := 12;
  Self.Similarity := 0.9999;

  Self.Map.Init();
  Self.Map.SetSize(Self.SIZE * Self.AMOUNT, Self.SIZE * Self.AMOUNT);

  Self.RoomsMap.Init();
  Self.RoomsMap.LoadFromFile(WALKER_DIR + 'poh.png');

  SetLength(Self.Rooms, Self.AMOUNT);
  for i := 0 to High(Self.Rooms) do
    SetLength(Self.Rooms[i], Self.AMOUNT);

  AddOnTerminate(@Self.Free);

  for obj := Low(ERSRoomObject) to High(ERSRoomObject) do
    Self.RoomObjects[obj].Setup(obj);
end;

(*
# POH.GetRoomBitmapBox()
```pascal
function TRSPOHHandler.GetRoomBitmapBox(room: ERSHouseRoom): TBox;
```
Internal method used to get the box of the `ERSHouseRoom` you pass in.
This box is a box of the following image:
```{figure} ../../../osr/walker/poh.png
```
Example:
```pascal
{$I WaspLib/optional/handlers/poh.simba}
begin
  WriteLn POH.GetRoomBitmapBox(ERSHouseRoom.SUPERIOR_GARDEN);
end;
```
*)
function TRSPOHHandler.GetRoomBitmapBox(room: ERSHouseRoom): TBox;
var
  i: Int32;
begin
  i := Ord(room)-1;
  Result := [i * Self.SIZE, 0, i * Self.SIZE + Self.SIZE - 1, Self.SIZE-1];
end;

(*
# POH.GetRoomBitmap()
```pascal
function TRSPOHHandler.GetRoomBitmap(room: ERSHouseRoom; color: Int32 = -1): TMufasaBitmap;
```
Internal method used to retrieve a bitmap of the `ERSHouseRoom` you pass in.
Example:
```pascal
{$I WaspLib/optional/handlers/poh.simba}
var
  bmp: TMufasaBitmap;
begin
  bmp := POH.GetRoomBitmapBox(ERSHouseRoom.SUPERIOR_GARDEN);
  bmp.Debug();
  bmp.Free();
end;
```
*)
function TRSPOHHandler.GetRoomBitmap(room: ERSHouseRoom; color: Int32 = -1): TMufasaBitmap;
var
  b: TBox;
begin
  if Self.RoomsBitmaps[room] = nil then
  begin
    b := Self.GetRoomBitmapBox(room);
    Result := Self.RoomsMap.Copy(b.X1, b.Y1, b.X2, b.Y2);
    Self.RoomsBitmaps[room] := Result.Copy();
  end
  else
    Result := Self.RoomsBitmaps[room].Copy();

  if color <> -1 then
    Result.ReplaceColor($FFFFFF, color);
end;


(*
# POH.WriteRoom()
```pascal
procedure TRSPOHHandler.WriteRoom(room: ERSHouseRoom; index: TPoint);
```
Internal method used to write a room to `POH.Rooms` cache.
This uses an `TPoint` as a room `index` in a 2D array of `ERSHouseRoom`.

Unless you know what you are doing, you definitly should not use this for anything.

Example:
```pascal
POH.WriteRoom(ERSHouseRoom.SUPERIOR_GARDEN, [3,3]);
```
*)
procedure TRSPOHHandler.WriteRoom(room: ERSHouseRoom; index: TPoint);
begin
  if not InRange(index.X, 0, High(Self.Rooms)) then
    TerminateScript('index.X is not between 0 and ' + ToStr(High(Self.Rooms)) + ', got ' + ToStr(index));
  if not InRange(index.Y, 0, High(Self.Rooms[0])) then
    TerminateScript('index.Y is not between 0 and ' + ToStr(High(Self.Rooms[0])) + ', got: ' + ToStr(index));

  Self.Rooms[index.Y,index.X] := room;
end;

(*
# POH.ReadRoom()
```pascal
function TRSPOHHandler.ReadRoom(index: TPoint): ERSHouseRoom;
```
Internal method used to read a cached room in `POH.Rooms`.
This uses an `TPoint` as a room `index`.

Unless you know what you are doing, you don't need this, but there's no harm in using it.

Example:
```pascal
WriteLn POH.ReadRoom([3,3]);
```
*)
function TRSPOHHandler.ReadRoom(index: TPoint): ERSHouseRoom;
begin
  if not InRange(index.X, 0, High(Self.Rooms)) then
    TerminateScript('p.X is not between 0 and ' + ToStr(High(Self.Rooms)) + ', got ' + ToStr(index));
  if not InRange(index.Y, 0, High(Self.Rooms[0])) then
    TerminateScript('p.Y is not between 0 and ' + ToStr(High(Self.Rooms[0])) + ', got: ' + ToStr(index));

  Result := Self.Rooms[index.Y,index.X];
end;


(*
# POH.PrintRooms()
```pascal
procedure TRSPOHHandler.PrintRooms();
```
Debugging helper method used to read a cached rooms in `POH.Rooms`.
This will print the whole cache nicely formated in a way that is human friendly like you were looking at the house map.

Unless you know what you are doing, you don't need this, but there's no harm in using it.

```{note}
:class: dropdown
It's a extremely useful debugging tool when paired with `POH.Map.Debug()`.
```

Example:
```pascal
POH.Setup();
POH.PrintRooms();
```
*)
procedure TRSPOHHandler.PrintRooms();
var
  str: String;
  i, j: Int32;
begin
  str := '[' + LineEnding;
  for i := 0 to High(Self.Rooms) do
  begin
    for j := 0 to High(Self.Rooms[i]) do
    begin
      if j = 0 then
      begin
        str += '  [';
      end;
        str += ToStr(Self.Rooms[i][j]);
      if j < High(Self.Rooms[i]) then
        str += ', ';
    end;
      str += ', ' + LineEnding;
  end;
  str += ']';
  WriteLn str;
end;

(*
# POH.DrawMap()
```pascal
procedure TRSPOHHandler.DrawMap(bmp: TMufasaBitmap; room: ERSHouseRoom; p: TPoint);
procedure TRSPOHHandler.DrawMap(room: ERSHouseRoom; color: Int32; p: TPoint); overload;
```
Methods used to draw the POH map and cache the rooms drawn in `POH.Rooms`.

Example:
```pascal
POH.DrawMap(ERSHouseRoom.SUPERIOR_GARDEN, POH.GrassColor, [3,3]);
```
*)
procedure TRSPOHHandler.DrawMap(bmp: TMufasaBitmap; room: ERSHouseRoom; p: TPoint);
begin
  Self.WriteRoom(room, p);
  Self.Map.DrawBitmap(bmp, [Self.SIZE * p.X, Self.SIZE * p.Y]);
end;

procedure TRSPOHHandler.DrawMap(room: ERSHouseRoom; color: Int32; p: TPoint); overload;
var
  bmp: TMufasaBitmap;
begin
  bmp := Self.GetRoomBitmap(room, color);
  Self.DrawMap(bmp, room, p);
  bmp.Free();
end;


(*
# POH.GetPointIndex()
```pascal
function TRSPOHHandler.GetPointIndex(p: TPoint): TPoint;
```
Helper method that converts a normal TPoint to a index used by {ref}`POH.ReadRoom()`.

Example:
```pascal
WriteLn POH.GetPointIndex(POH.GetPos());
```
*)
function TRSPOHHandler.GetPointIndex(p: TPoint): TPoint;
begin
  Result := [p.X div Self.SIZE, p.Y div Self.SIZE];
end;

(*
# POH.GetMappedRoom()
```pascal
function TRSPOHHandler.GetMappedRoom(p: TPoint): ERSHouseRoom;
```
Helper method that returns the cached room in `POH.Rooms`with the help of
{ref}`POH.GetPointIndex()` and {ref}`POH.ReadRoom()`.

Example:
```pascal
WriteLn POH.GetMappedRoom(POH.GetPos());
```
*)
function TRSPOHHandler.GetMappedRoom(p: TPoint): ERSHouseRoom;
begin
  Result := Self.ReadRoom(Self.GetPointIndex(p));
end;

(*
# POH.GetMappedRoomTopLeft()
```pascal
function TRSPOHHandler.GetMappedRoomTopLeft(p: TPoint): TPoint;
```
Helper method that returns the top left point of a mapped room that the specified `p` belongs to.
This is required to do accurate "room math".

Example:
```pascal
WriteLn POH.GetMappedRoomTopLeft(POH.GetPos());
```
*)
function TRSPOHHandler.GetMappedRoomTopLeft(p: TPoint): TPoint;
begin
  Result := [p.X div Self.SIZE * Self.SIZE, p.Y div Self.SIZE * Self.SIZE];
end;

(*
# POH.GetAdjacentRoomsMinimap()
```pascal
function TRSPOHHandler.GetAdjacentRoomsMinimap(p: TPoint): TPointArray;
```
Helper method that returns coordinates that belong to the north, west, south and east rooms of the point passed in.
This assumes the compass is set to `0` (North) or that you've rotated your coordinates so the math works as if you had the compass set that way.
Ideally, you will want to pass in a room top left corner to this to get the top left corner of each adjacent room.
*)
function TRSPOHHandler.GetAdjacentRoomsMinimap(p: TPoint): TPointArray;
begin
  Result := [p.Offset(-32,0), p.Offset(32, 0), p.Offset(0, -32), p.Offset(0, 32)];
end;

(*
# POH.GetAdjacentRoomsIndices()
```pascal
function TRSPOHHandler.GetAdjacentRoomsIndices(index: TPoint): TPointArray;
```
Helper method that returns indices of the adjacent rooms (north, west, south and east) on the `POH.Rooms` cache.
*)
function TRSPOHHandler.GetAdjacentRoomsIndices(index: TPoint): TPointArray;
begin
  Result := [index.Offset(-1,0), index.Offset(1, 0), index.Offset(0, -1), index.Offset(0, 1)];
end;


function TRSPOHHandler.GetMinimapRoomCoordinate(topLeft, p: TPoint; angle: Double; rotation: Int32): TPoint;
var
  roomCenter: TPoint;
begin
  if not InRange(p.X, 0, 32) or not InRange(p.Y, 0, 32) then
    TerminateScript(ToStr(p) + ' is not wthin the room you want to check.');

  Result := topLeft + p + [Minimap.X1(), Minimap.Y1()] - [10, 10];
  Result := Result.Rotate(angle, Minimap.Center());

  if rotation = 0 then
    Exit;

  roomCenter := topLeft + [16, 16] + [Minimap.X1(), Minimap.Y1()] - [10, 10];
  roomCenter := roomCenter.Rotate(angle, Minimap.Center());
  Result := Result.Rotate(PI/2 * rotation, roomCenter);
end;

function TRSPOHHandler.GetCuboid(topLeft, p: TPoint; tile: Vector3; angle: Double; rotation: Int32): TCuboidEx;
begin
  p := Self.GetMinimapRoomCoordinate(topLeft, p, angle, rotation);
  Result := Minimap.GetCuboidMS(p, tile);
end;


function TRSPOHHandler.Contains(objType: ERSRoomObject; topLeft: TPoint; angle: Double; rotation: Int32): Boolean;
var
  obj: TRoomObject;
  cuboid: TCuboidEx;
begin
  obj := Self.RoomObjects[objType];
  if obj.Coordinates <> [] then
    Exit;

  cuboid := Self.GetCuboid(topLeft, obj.RoomOffset, obj.Shape, angle, rotation);
  Result := MainScreen.FindObject(obj.Finder, cuboid.Bounds()) <> [];
end;

procedure TRSPOHHandler.MapRoomObjects(room: ERSHouseRoom; topLeft: TPoint; roomIndex: TPoint; angle: Double);
var
  rotation: Int32;
  p, center: TPoint;
  obj: ERSRoomObject;
begin
  case room of
    ERSHouseRoom.SUPERIOR_GARDEN:
    begin
      roomIndex := [roomIndex.X * 32, roomIndex.Y * 32];
      center := roomIndex.Offset(16,16);

      for rotation := 0 to 3 do
      begin
        obj := ERSRoomObject.POOL;
        if Self.Contains(obj, topLeft, angle, rotation) then
        begin
          p := roomIndex + Self.RoomObjects[obj].RoomOffset;
          p := p.Rotate(PI/2*rotation, center);
          Self.RoomObjects[obj].AddCoordinates([p]);
        end;

        obj := ERSRoomObject.FAIRY_TREE;
        if Self.Contains(obj, topLeft, angle, rotation) then
          Self.RoomObjects[obj].AddCoordinates([center]);
      end;
    end;

    ERSHouseRoom.ACHIEVEMENT_GALLERY:
    begin
      roomIndex := [roomIndex.X * 32, roomIndex.Y * 32];
      center := roomIndex.Offset(16,16);

      for rotation := 0 to 3 do
      begin
        obj := ERSRoomObject.JEWELLERY_BOX;
        if Self.Contains(obj, topLeft, angle, rotation) then
        begin
          p := roomIndex + Self.RoomObjects[obj].RoomOffset;
          p := p.Rotate(PI/2*rotation, center);

          Self.RoomObjects[obj].AddCoordinates([p]);
        end;
      end;
    end;
  end;
end;

function TRSPOHHandler.RotateRoom(bitmap: TMufasaBitmap; rotation: Int32): TMufasaBitmap;
var
  p: TPoint;
begin
  if rotation = 0 then
    Exit(bitmap.Copy());

  bitmap.Pad(1);
  Result.Init();
  bitmap.RotateBitmap(PI/2*rotation, Result);

  for p.X := 0 to 3 do
    for p.Y := 0 to 3 do
      if Result.GetPixel(p.X, p.Y) <> 0 then
        Break(2);

  Result.Crop(p.X, p.Y, p.X + 31, p.Y + 31);
end;

procedure TRSPOHHandler.MapAdjacentRooms(minimapBMP: TMufasaBitmap; topLeft, currentRoom: TPoint; angle: Double);
const
  FLOOR_COLOR_OFFSETS: TPointArray = [[5,5], [26,5], [26,26], [5, 26]];
var
  minimapTPA, localTPA: TPointArray;
  p: TPoint;
  crop, sample, rotated, bestBMP: TMufasaBitmap;
  i, j, floor, r: Int32;
  colors: TIntegerArray;
  bestRoom: ERSHouseRoom;
  matrix: TSingleMatrix;
  match, bestMatch: Single;
  hasCoreObject: Boolean;
begin
  localTPA := Self.GetAdjacentRoomsIndices(currentRoom);
  minimapTPA := Self.GetAdjacentRoomsMinimap(topLeft);

  for i := 0 to High(minimapTPA) do
  begin
    p := minimapTPA[i];
    if Self.ReadRoom(localTPA[i]) <> ERSHouseRoom.UNKNOWN then
      Continue;

    crop := minimapBMP.Copy(p.X, p.Y, p.X + Self.SIZE-1, p.Y + Self.SIZE-1);

    colors := crop.GetPixels(FLOOR_COLOR_OFFSETS);
    floor := colors.GetMostCommon();

    for j := 1 to Ord(High(ERSHouseRoom)) do
    begin
      case j of
        0..3: if floor <> Self.GrassColor then Continue; //Gardens or OpenMenagerie
        else  if floor = Self.GrassColor then Continue;
      end;

      sample := Self.GetRoomBitmap(ERSHouseRoom(j), floor);
      for r := 0 to 3 do
      begin
        rotated := Self.RotateRoom(sample, r);

        case j of
          2: hasCoreObject := Self.Contains(ERSRoomObject.POOL, p, angle, r);
          7: hasCoreObject := Self.Contains(ERSRoomObject.JEWELLERY_BOX, p, angle, r);
        end;

        matrix := crop.MatchTemplate(rotated, TM_CCOEFF_NORMED);
        match := matrix.Max();
        if hasCoreObject then
          match += 0.2;

        if match > bestMatch then
        begin
          if bestBMP <> nil then
            bestBMP.Free();

          bestBMP := rotated;
          bestMatch := match;
          bestRoom := ERSHouseRoom(j);
          Continue;
        end;

        rotated.Free();

        if bestMatch >= Self.Similarity then
          Break(2);
      end;
    end;

    crop.Free();
    if bestMatch > 0.3 then
    begin
      Self.DrawMap(bestBMP, bestRoom, localTPA[i]);
      Self.MapRoomObjects(bestRoom, p, localTPA[i], angle);
      bestMatch := 0;
    end;
  end;
  bestBMP.Free();
end;


function TRSPOHHandler.GetCleanMinimap(out angle: Double): TMufasaBitmap; static;
var
  bitmap: TMufasaBitmap;
begin
  bitmap := GetMufasaBitmap(BitmapFromClient(Minimap.Bounds()));
  bitmap.ReplaceColor(0, 1); // We need zero to be unique

  TRSWalker.CleanMinimap(Bitmap);

  Result.Init();
  angle := Minimap.GetCompassAngle(False);
  bitmap.RotateBitmapEx(angle, False, True, Result);
  bitmap.Free();
end;

function TRSPOHHandler.GetCleanMinimap(): TMufasaBitmap; static; overload;
var
  angle: Double;
begin
  Result := TRSPOHHandler.GetCleanMinimap(angle);
end;

procedure TRSPOHHandler.Setup();
var
  minimapBMP: TMufasaBitmap;
  p, center, topLeft: TPoint;
  angle: Double;
begin
  minimapBMP := TRSPOHHandler.GetCleanMinimap(angle);
  center := minimapBMP.getCenter();
  Self.GrassColor := minimapBMP.GetPixel(center.X, center.Y);
  minimapBMP.ReplaceColor(1, Self.GrassColor);

  Self.Map.ReplaceColor(0, Self.GrassColor);

  p := [Self.AMOUNT div 2, Self.AMOUNT div 2];
  Self.DrawMap(ERSHouseRoom.GARDEN, Self.GrassColor, p);
  topLeft := center.Offset(-14, -10);
  Self.MapAdjacentRooms(minimapBMP, topLeft, p, angle);

  minimapBMP.Free();
end;


procedure TRSPOHHandler.LoadSuroundings(minimapBMP: TMufasaBitmap; p: TPoint; angle: double);
var
  topLeft: TPoint;
begin
  topLeft := p - Self.GetMappedRoomTopLeft(p);
  topLeft := minimapBMP.getCenter() - topLeft - [1,0];
  Self.MapAdjacentRooms(minimapBMP, topLeft, Self.GetPointIndex(p), angle);
end;


function TRSPOHHandler.SampleSearch(minimapBMP: TMufasaBitmap; sampleSize: Int32 = 50; sampleAmount: Int32 = 3): TPoint;
var
  sampleSM, sampleLG: TMufasaBitmap;
  offset: TPoint;
  b: TBox;
  matrixSM, matrixLG: TSingleMatrix;
  resultSM, resultLG: TPointArray;
  i, j, s: Int32;
  p: TPoint;
begin
  s := 20;
  offset := minimapBMP.getCenter().Offset(2, 5);
  b := Box(offset, s, s);
  sampleSM := minimapBMP.Copy(b.X1, b.Y1, b.X2, b.Y2);
  b := Box(offset, sampleSize, sampleSize);
  sampleLG := minimapBMP.Copy(b.X1, b.Y1, b.X2, b.Y2);

  matrixSM := Self.Map.MatchTemplate(sampleSM, TM_CCOEFF_NORMED);
  matrixLG := Self.Map.MatchTemplate(sampleLG, TM_CCOEFF_NORMED);

  sampleSM.Free();
  sampleLG.Free();

  Dec(sampleAmount);

  for i := 0 to sampleAmount do
    with matrixSM.ArgMax() do
    begin
      p := Point(X - (sampleSize - s), Y - (sampleSize - s)).Offset(sampleSize - 3, sampleSize - 5);
      if Self.GetMappedRoom(p) <> ERSHouseRoom.UNKNOWN then
        resultSM += p
      else
        Dec(i);
      matrixSM.Fill([X - 5, Y - 5, X + 5, Y + 5], 0);
    end;

  for i := 0 to sampleAmount do
    with matrixLG.ArgMax() do
    begin
      p := Point(X, Y).Offset(sampleSize - 3, sampleSize - 5);
      if Self.GetMappedRoom(p) <> ERSHouseRoom.UNKNOWN then
        resultLG += p
      else
        Dec(i);
      matrixLG.Fill([X - 5, Y - 5, X + 5, Y + 5], 0);
    end;

  for i := 0 to High(resultLG) do
    for j := 0 to High(resultSM) do
      if resultLG[i].WithinDistance(resultSM[j], 6) then
        Exit(resultLG[i]);

  Result := resultSM[0];
end;

function TRSPOHHandler.GetPos(): TPoint;
const
  SAMPLE_SIZE: Int32 = 50;
var
  minimapBMP: TMufasaBitmap;
  angle: Double;
begin
  minimapBMP := TRSPOHHandler.GetCleanMinimap(angle);
  minimapBMP.ReplaceColor(1, Self.GrassColor);

  Result := Self.SampleSearch(minimapBMP, SAMPLE_SIZE);
  Self.LoadSuroundings(minimapBMP, Result, angle);
  minimapBMP.Free();
end;

procedure TRSPOHHandler.DebugPos();
const
  SAMPLE_SIZE: Int32 = 50;
var
  minimapBMP, display: TMufasaBitmap;
  p: TPoint;
  angle: Double;
begin
  minimapBMP := TRSPOHHandler.GetCleanMinimap(angle);
  minimapBMP.ReplaceColor(1, Self.GrassColor);

  p := Self.SampleSearch(minimapBMP, SAMPLE_SIZE);

  Self.LoadSuroundings(minimapBMP, p, angle);

  display.Init();
  display.SetSize(Self.Map.getWidth() + minimapBMP.getWidth() + 300, Self.Map.getHeight());

  display.DrawBitmap(Self.Map, [0,0]);
  display.setFontAntialiasing(True);
  display.DrawText('MAP', [10, 10], $FFFFFF);
  display.setFontSize(14);
  display.DrawText('Minimap sample:', [Self.Map.getWidth()+10, 0], $FFFFFF);
  display.DrawBitmap(minimapBMP, [Self.Map.getWidth()+1, 20]);

  display.setFontSize(10);
  display.DrawText('Pos:' + ToStr(p), [Self.Map.getWidth()+10, minimapBMP.getHeight() + 40], $FFFFFF);

  display.DrawCrosshairs(p, 1, $FFFFFF);
  display.Debug();

  minimapBMP.Free();
  display.Free();
end;

function TRSPOHHandler.GetCurrentRoom(): ERSHouseRoom;
begin
  Result := Self.GetMappedRoom(Self.GetPos());
end;


function TRSPOHHandler.MapToMM(me, handlerPoint: TPoint; radians: Double): TPoint;
begin
  Result := handlerPoint - me + Minimap.Center();
  Result := Result.Rotate(radians, Minimap.Center());
end;

function TRSPOHHandler.MapToMM(walkerPoint: TPoint): TPoint; overload;
begin
  Result := Self.MapToMM(Self.GetPos(), walkerPoint, Minimap.GetCompassAngle(False));
end;

function TRSPOHHandler.MapToMM(me: TPoint; tpa: TPointArray; radians: Double): TPointArray; overload;
var
  p: TPoint;
begin
  for p in tpa do
    Result += Self.MapToMM(me, p, radians);
end;

function TRSPOHHandler.MapToMM(tpa: TPointArray): TPointArray; overload;
begin
  Result := Self.MapToMM(Self.GetPos(), tpa, Minimap.GetCompassAngle(False));
end;

function TRSPOHHandler.Hover(objType: ERSRoomObject): Boolean;
var
  obj: TRoomObject;
  mmPoints: TPointArray;
  radians: Double;
  me: TPoint;
begin
  me := Self.GetPos();
  obj := Self.RoomObjects[objType];
  if obj.Coordinates = [] then
    Exit;

  radians := Minimap.GetCompassAngle(False);
  mmPoints := Self.MapToMM(me, obj.Coordinates, radians);
  Result := obj.Hover(mmPoints, radians);
end;

function TRSPOHHandler.Click(objType: ERSRoomObject): Boolean;
var
  obj: TRoomObject;
  mmPoints: TPointArray;
  radians: Double;
  me: TPoint;
begin
  me := Self.GetPos();
  obj := Self.RoomObjects[objType];
  if obj.Coordinates = [] then
    Exit;

  radians := Minimap.GetCompassAngle(False);
  mmPoints := Self.MapToMM(me, obj.Coordinates, radians);
  Result := obj.Click(mmPoints, radians);
end;

function TRSPOHHandler.Select(objType: ERSRoomObject; options: TStringArray): Boolean;
var
  obj: TRoomObject;
  mmPoints: TPointArray;
  radians: Double;
  me: TPoint;
begin
  me := Self.GetPos();
  obj := Self.RoomObjects[objType];
  if obj.Coordinates = [] then
    Exit;

  radians := Minimap.GetCompassAngle(False);
  mmPoints := Self.MapToMM(me, obj.Coordinates, radians);
  Result := obj.Select(options, mmPoints, radians);
end;

var
  POH: TRSPOHHandler;

procedure TSRL.Setup(); override;
begin
  inherited;
  POH.Init();
end;

(*
begin
  POH.Setup();
  POH.Click(ERSRoomObject.POOL);
  Wait(5000);
  POH.Click(ERSRoomObject.JEWELLERY_BOX);
  while True do
    POH.DebugPos();
end;
*)
